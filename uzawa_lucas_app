import streamlit as st
import numpy as np
import matplotlib.pyplot as plt

# -------------------------------------------------------
# PAGE CONFIG
# -------------------------------------------------------
st.set_page_config(
    page_title="Uzawa‚ÄìLucas Model Simulator",
    layout="wide"
)

st.title("üìà Uzawa‚ÄìLucas Model Simulator")
st.markdown("""
This application allows you to explore the dynamics of the Uzawa‚ÄìLucas model  
under **competitive equilibrium** and **social planner** allocations.  
Use the parameter panel on the left to adjust preferences, technology,  
and depreciation, and observe how the growth paths change.
""")

# -------------------------------------------------------
# SIDEBAR ‚Äî PARAMETER PANEL
# -------------------------------------------------------
st.sidebar.header("Model Parameters")

beta = st.sidebar.slider("Œ≤ ‚Äî capital share", 0.05, 0.9, 0.30, 0.01)
gamma = st.sidebar.slider("Œ≥ ‚Äî externality strength", 0.00, 0.6, 0.20, 0.01)
delta = st.sidebar.slider("Œ¥ ‚Äî human-capital technology", 0.01, 0.20, 0.08, 0.01)
rho_minus_lambda = st.sidebar.slider("œÅ ‚àí Œª", 0.00, 0.20, 0.04, 0.01)
lambda_param = st.sidebar.slider("Œª ‚Äî physical-capital depreciation", 0.00, 0.10, 0.01, 0.005)
theta = st.sidebar.slider("Œ∏ ‚Äî inverse elasticity of intertemporal substitution", 0.5, 5.0, 2.0, 0.1)

T = st.sidebar.number_input("Time horizon T", 50, 1000, 200)
dt = st.sidebar.number_input("Time step dt", 0.01, 1.0, 0.1)
N = int(T / dt)


# -------------------------------------------------------
# GROWTH RATE FUNCTIONS
# -------------------------------------------------------
def nu_equilibrium(theta):
    num = (1 - beta) * (delta - rho_minus_lambda)
    den = theta * (1 - beta + gamma) - gamma
    if den <= 0:
        return 0
    return min(num / den, delta)

def nu_planner(theta):
    val = (delta - (1 - beta)/(1 - beta + gamma) * rho_minus_lambda) / theta
    return min(val, delta)


# -------------------------------------------------------
# DYNAMICS SIMULATION
# -------------------------------------------------------
def simulate(is_planner=False):
    k = np.zeros(N)
    h = np.zeros(N)
    u = np.zeros(N)
    c = np.zeros(N)
    y = np.zeros(N)

    k[0] = 1.0
    h[0] = 1.0
    u[0] = 0.4

    if is_planner:
        nu_val = nu_planner(theta)
    else:
        nu_val = nu_equilibrium(theta)

    u_val = 1 - nu_val / delta
    u_val = np.clip(u_val, 0, 1)

    for t in range(N - 1):
        y[t] = k[t]**beta * (u[t] * h[t])**(1 - beta) * h[t]**gamma
        c[t] = 0.3 * y[t]
        k[t+1] = k[t] + dt * (y[t] - c[t] - lambda_param * k[t])
        h[t+1] = h[t] + dt * (delta * (1 - u[t]) * h[t])
        u[t+1] = u[t] + dt * 0.1 * (u_val - u[t])

    y[-1] = k[-1]**beta * (u[-1] * h[-1])**(1 - beta) * h[-1]**gamma
    c[-1] = 0.3 * y[-1]

    return k, h, u, c, y


# -------------------------------------------------------
# RUN BOTH SIMULATIONS
# -------------------------------------------------------
k_e, h_e, u_e, c_e, y_e = simulate(is_planner=False)
k_p, h_p, u_p, c_p, y_p = simulate(is_planner=True)
time = np.linspace(0, T, N)


# -------------------------------------------------------
# PLOT 1 ‚Äî Time paths of k(t), c(t), y(t)
# -------------------------------------------------------
st.header("1. Time Paths of k(t), c(t), y(t)")

fig1, ax1 = plt.subplots(figsize=(8, 4))
ax1.plot(time, k_e, label="k(t)")
ax1.plot(time, c_e, label="c(t)")
ax1.plot(time, y_e, label="y(t)")
ax1.set_xlabel("time")
ax1.set_title("Equilibrium time paths (k, c, y)")
ax1.legend()
st.pyplot(fig1)

st.markdown("""
**Interpretation:**  
These curves show how capital, consumption, and output evolve over time  
given the competitive-equilibrium time allocation.  
Increasing **Œ≥** amplifies output through external effects,  
while higher **Œ¥** speeds up human-capital accumulation.
""")


# -------------------------------------------------------
# PLOT 2 ‚Äî u(t) and h(t)
# -------------------------------------------------------
st.header("2. Human Capital and Time Allocation (u,h)")

fig2, ax1 = plt.subplots(figsize=(8, 4))
ax1.plot(time, u_e, color="blue", label="u(t)")
ax1.set_ylabel("u(t)", color="blue")
ax2 = ax1.twinx()
ax2.plot(time, h_e, color="orange", linestyle="--", label="h(t)")
ax2.set_ylabel("h(t)", color="orange")
ax1.set_xlabel("time")
ax1.set_title("Equilibrium: u(t) and h(t)")
st.pyplot(fig2)

st.markdown("""
**Interpretation:**  
Households choose **u(t)** too high in equilibrium when Œ≥>0,  
meaning they devote *too little time* to human-capital accumulation.
""")


# -------------------------------------------------------
# PLOT 3 ‚Äî Log paths: equilibrium vs planner
# -------------------------------------------------------
st.header("3. Comparison of Log-Paths (Equilibrium vs Planner)")

fig3, ax3 = plt.subplots(figsize=(8, 4))
ax3.plot(time, np.log(k_e), label="log k_e (equilibrium)")
ax3.plot(time, np.log(h_e), label="log h_e (equilibrium)")
ax3.plot(time, np.log(k_p), linestyle="--", label="log k_p (planner)")
ax3.plot(time, np.log(h_p), linestyle="--", label="log h_p (planner)")
ax3.set_xlabel("time")
ax3.set_ylabel("log levels")
ax3.set_title("Log paths of k(t) and h(t)")
ax3.legend()
st.pyplot(fig3)

st.markdown("""
**Interpretation:**  
The planner internalizes the Œ≥ externality ‚Üí allocates more time to education ‚Üí  
growth rates of both **k(t)** and **h(t)** increase relative to equilibrium.
""")

st.success("Model simulation completed successfully!")
